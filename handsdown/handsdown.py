import importlib
import inspect
import pyclbr
import re
import logging
from pathlib import Path
from collections import defaultdict
from unittest.mock import patch
from typing import Iterable, Text, List, Any, Tuple, Optional, Callable, Dict

from handsdown.loader import Loader
from handsdown.processors.smart import SmartDocstringProcessor


class Handsdown:
    """
    Doc generator.

    Arguments:
        repo_path -- Path to repo to generate docs.
    """

    _anchor_re = re.compile(r"[^a-z0-9_-]+")

    def __init__(
        self, repo_path: Path, logger: Optional[logging.Logger] = None
    ) -> None:
        self._logger = logger or logging.Logger("handsdown")
        self._repo_path = repo_path
        self._docs_path = self._repo_path / "docs"
        self._docs_path.mkdir(exist_ok=True)
        self._loader = Loader()
        self._docstring_processor = SmartDocstringProcessor()
        self._module_md_map: Dict[Text, Text] = {}
        self._docstring_links_re: re.Pattern = re.compile("")
        self._signature_links_re: re.Pattern = re.compile("")

    @staticmethod
    def _get_predicate(object_name: Text) -> Callable[[Any], bool]:
        def predicate(method: Any) -> bool:
            if not inspect.isroutine(method) or not method.__doc__:
                return False

            parent_name = method.__qualname__.split(".")[0]
            method_name = method.__qualname__.split(".")[-1]

            # skip magic methods
            if method.__qualname__ == parent_name:
                return False

            # skip private methods
            if method_name.startswith("_"):
                return False

            # skip inherited methods
            if parent_name != object_name:
                return False

            # skip built-in inherited methods
            if object_name not in repr(method):
                return False

            return True

        return predicate

    def _get_module_objects(
        self, inspect_module: Any, import_string: Text
    ) -> List[Tuple[Text, Any, int]]:
        result = []
        for object_name in pyclbr.readmodule_ex(import_string):
            if object_name.startswith("__"):
                continue

            inspect_object = getattr(inspect_module, object_name)
            if not inspect.isclass(inspect_object) and inspect_object.__doc__ is None:
                continue
            result.append((object_name, inspect_object, 0))
            for method_name, inspect_method in inspect.getmembers(
                inspect_object, self._get_predicate(object_name)
            ):
                title = f"{object_name}().{method_name}"
                if isinstance(inspect_method, (staticmethod, classmethod)):
                    title = f"{object_name}.{method_name}"

                result.append((title, inspect_method, 1))

        return result

    def cleanup_old_docs(self, preserve_paths: Iterable[Path]) -> None:
        """
        Remove old docs generated for this module.

        Arguments:
            preserve_paths -- All doc files generated paths that should not be deleted.
        """
        preserve_file_names = [i.name for i in preserve_paths]
        for doc_path in self._docs_path.glob("*.md"):
            md_name = doc_path.name
            if md_name in preserve_file_names:
                continue

            file_content = doc_path.read_text()
            is_autogenerated = "Auto-generated documentation" in file_content
            if is_autogenerated:
                self._logger.info(f"Deleting orphaned doc file {md_name}")
                doc_path.unlink()

    def _build_module_md_map(self, source_paths: Iterable[Path]) -> Dict[Text, Text]:
        module_md_map: Dict[Text, Text] = {}
        for file_path in source_paths:
            if not (file_path.parent / "__init__.py").exists():
                continue

            relative_file_path = file_path.relative_to(self._repo_path)
            file_import = self._get_file_import_string(relative_file_path)

            with patch("os.environ", defaultdict(lambda: "env")):
                inspect_module = importlib.import_module(file_import)

            md_name = self._get_md_name(relative_file_path)
            module_objects = self._get_module_objects(inspect_module, file_import)

            module_md_map[file_import] = md_name
            for module_object_name, _, _ in module_objects:
                module_object_name = module_object_name.replace("(", "").replace(
                    ")", ""
                )
                module_md_map[f"{file_import}.{module_object_name}"] = md_name

        return module_md_map

    def generate(self, source_paths: Iterable[Path]) -> Text:
        """
        Generate module docs.

        Arguments:
            package_names -- package names to include.

        Returns:
            A string with new file content.
        """
        processed_paths: List[Path] = []
        generated_files: List[Path] = []
        self._module_md_map = self._build_module_md_map(source_paths)
        package_names = {i.split(".")[0] for i in self._module_md_map}

        self._docstring_links_re = re.compile(f'`(?:{"|".join(package_names)})\\.\\S+`')
        self._signature_links_re = re.compile(
            f' ((?:{"|".join(package_names)})\\.[^() :,]+)'
        )

        for file_path in source_paths:
            if not (file_path.parent / "__init__.py").exists():
                continue

            relative_file_path = file_path.relative_to(self._repo_path)
            file_import = self._get_file_import_string(relative_file_path)

            with patch("os.environ", defaultdict(lambda: "env")):
                inspect_module = importlib.import_module(file_import)

            module_objects = self._get_module_objects(inspect_module, file_import)
            docstring = inspect_module.__doc__

            if not module_objects and not docstring:
                continue

            md_name = self._get_md_name(relative_file_path)
            target_file = self._docs_path / md_name
            processed_paths.append(relative_file_path)
            generated_files.append(target_file)

            self._logger.debug(f"Generating {md_name}")

            header_lines = self._generate_module_doc_header_lines(
                inspect_module=inspect_module, source_path=relative_file_path
            )

            content_lines = self._generate_module_doc_lines(
                module_objects=module_objects, source_path=relative_file_path
            )

            toc_lines = self._build_toc_lines(header_lines + content_lines)
            md_lines = []
            md_lines.extend(header_lines[:2])
            md_lines.extend(toc_lines)
            md_lines.append("")
            md_lines.extend(header_lines[2:])
            md_lines.extend(content_lines)

            target_file.write_text("\n".join(md_lines))
            self._replace_links(target_file)

        self.cleanup_old_docs(generated_files)

        index_md_content = self._generate_index_md_content(processed_paths)
        Path(self._docs_path, "index.md").write_text(index_md_content)

    @staticmethod
    def _get_title_from_import_string(import_string: Text) -> Text:
        title = import_string.split(".")[-1]
        return title

    def _replace_links(self, file_path: Path):
        content = file_path.read_text()
        file_changed = False
        for match in re.findall(self._docstring_links_re, content):
            module_name = match.replace("`", "")
            if module_name not in self._module_md_map:
                continue

            md_file_name = self._module_md_map[module_name]
            if md_file_name == file_path.name:
                continue

            title = self._get_title_from_import_string(module_name)
            anchor_link = self._get_anchor(title)
            link = f"[{title}](./{md_file_name}#{anchor_link})"
            content = content.replace(match, link)
            file_changed = True

        if file_changed:
            file_path.write_text(content)

    def _generate_module_doc_header_lines(
        self, inspect_module: Any, source_path: Path
    ) -> List[Text]:
        import_string = self._get_file_import_string(source_path)
        lines = []

        # Grab README.md content for __init__.py if it exists
        if source_path.name == "__init__.py":
            if (source_path.parent / "README.md").exists():
                for line in (source_path.parent / "README.md").read_text().split("\n"):
                    lines.append(line.rstrip())

            lines.append("")

        formatted_docstring = self._get_formatted_docstring(
            source_path=source_path, module_object=inspect_module
        )
        if formatted_docstring:
            docstring_lines = formatted_docstring.split("\n")
            for line in docstring_lines:
                lines.append(line.rstrip())

            lines.append("")

        if not lines or not lines[0].startswith("# "):
            page_title = self._get_title_from_path(source_path)
            lines.insert(0, "")
            lines.insert(0, f"# {page_title}")

        lines.insert(
            1,
            f"> Auto-generated documentation for [{import_string}](../{source_path}) module.",
        )
        lines.insert(1, "")

        if lines[-1]:
            lines.append("")

        return lines

    def _generate_module_doc_lines(
        self, module_objects: List[Tuple[Text, Any, int]], source_path: Path
    ) -> List[Text]:
        lines = []
        for module_object_name, module_object, level in module_objects:
            lines.append(f'{"#" * (level + 2)} {module_object_name}\n')

            signature = self._loader.get_object_signature(module_object)

            if signature:
                source_code_info = inspect.findsource(module_object)
                source_line_number = source_code_info[1] + 1
                lines.append(
                    f"[🔍 find in source code](../{source_path}#L{source_line_number})\n"
                )
                lines.append(f"```python\n{signature}\n```")

            formatted_docstring = self._get_formatted_docstring(
                source_path=source_path, module_object=module_object
            )
            if formatted_docstring:
                lines.extend(formatted_docstring.split("\n"))
                lines.append("")

        return lines

    def _get_formatted_docstring(
        self, source_path: Path, module_object: Any
    ) -> Optional[Text]:
        current_md_name = self._get_md_name(source_path)
        docstring = self._loader.get_object_docstring(module_object)
        if not docstring:
            return None

        sections = self._docstring_processor.build_sections(docstring)
        signature = self._loader.get_object_signature(module_object)
        if signature:
            existing_titles = []
            for match in re.findall(self._signature_links_re, signature):
                if match not in self._module_md_map:
                    continue

                md_name = self._module_md_map[match]
                if md_name == current_md_name:
                    continue

                title = self._get_title_from_import_string(match)
                if title in existing_titles:
                    continue

                existing_titles.append(title)
                anchor_link = self._get_anchor(title)
                sections["See also"].append(f"- [{title}](./{md_name}#{anchor_link})")

        formatted_docstring = self._docstring_processor.render_sections(sections)
        return formatted_docstring.strip("\n")

    def _generate_index_md_content(self, source_paths: Iterable[Path]) -> Text:
        """
        Get new `docs/index.md` file content.

        Returns:
            A string with new file content.
        """
        lines = []
        readme_path = Path(self._repo_path / "README.md")
        if readme_path.exists():
            lines.extend(readme_path.read_text().split("\n"))
        lines.append("\n## Modules\n")
        last_path_parts = []
        for source_path in source_paths:
            md_name = self._get_md_name(source_path)
            path_parts = source_path.parts

            if path_parts[-1] == "__init__.py":
                path_parts = path_parts[:-1]

            for part_index, path_part in enumerate(path_parts):
                if (
                    len(last_path_parts) > part_index
                    and path_part == last_path_parts[part_index]
                ):
                    continue
                indent = "  " * part_index
                if part_index == len(path_parts) - 1:
                    title = self._get_title_from_md_content(
                        (self._docs_path / md_name).read_text()
                    )
                    title = title.split(": ")[-1]
                    lines.append(f"{indent}- [{title}](./{md_name})")
                else:
                    title = self._get_title_from_path(Path(path_part))
                    lines.append(f"{indent}- {title}")

            last_path_parts = path_parts

        toc_lines = self._build_toc_lines(lines)
        lines.insert(1, "")
        lines.insert(1, "\n".join(toc_lines))

        return "\n".join(lines)

    def _get_anchor(self, title):
        title = title.lower().replace(" ", "-")
        result = self._anchor_re.sub("", title)
        return result

    def _build_toc_lines(
        self, file_lines: Iterable[Text], max_depth: int = 3
    ) -> List[Text]:
        toc_lines = []
        in_codeblock = False
        for line in file_lines:
            line = line.strip()
            if line.count("```") > 1:
                continue

            if line.startswith("```"):
                in_codeblock = not in_codeblock

            if in_codeblock:
                continue

            if not line.startswith("#"):
                continue

            header_symbols = line.split(" ")[0]
            if header_symbols.replace("#", ""):
                continue

            header_level = len(header_symbols)
            if header_level > max_depth:
                continue

            title = line.split(" ", 1)[-1].strip()
            anchor = self._get_anchor(title)
            link = f"[{title}](#{anchor})"
            toc_lines.append(f'{"  " * (header_level- 1)}- {link}')

        return toc_lines

    @staticmethod
    def _get_md_name(path: Path) -> Text:
        name_parts = []
        for part in path.parts:
            if part == "__init__.py":
                part = "index"
            stem = part.split(".")[0]
            name_parts.append(stem)

        if not name_parts:
            return "stub.md"

        return f"{'_'.join(name_parts)}.md"

    @staticmethod
    def _get_file_import_string(path: Path) -> Text:
        name_parts = []
        for part in path.parts:
            stem = part.split(".")[0]
            if stem == "__init__":
                continue
            name_parts.append(stem)

        return f"{'.'.join(name_parts)}"

    @staticmethod
    def _get_title_from_path(path: Path) -> Text:
        """
        Converts `pathlib.Path` to a human readable title.

        Arguments:
            path: Relative path to file or folder

        Returns:
            Human readable title.
        """
        path_parts = path.parts
        name_parts = []
        for path_part in path_parts:
            if path_part == "__init__.py":
                continue
            name = path_part.split(".")[0]
            name = name.replace("__", "").replace("_", " ")
            name = name.capitalize()
            name_parts.append(name)

        if name_parts:
            return ": ".join(name_parts)

        return "Index"

    @staticmethod
    def _get_title_from_md_content(content: Text) -> Optional[Text]:
        lines = content.split("\n")[:10]
        for line in lines:
            if line.startswith("# "):
                return line.split(" ", 1)[-1].strip()

        return None
