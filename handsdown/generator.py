import re
import logging
from pathlib import Path
from typing import Iterable, Text, List, Optional, Union

from handsdown.loader import Loader, LoaderError
from handsdown.processors.smart import SmartDocstringProcessor
from handsdown.processors.base import BaseDocstringProcessor
from handsdown.module_record import ModuleRecord, ModuleObjectRecord, ModuleRecordList
from handsdown.md_document import MDDocument


class GeneratorError(Exception):
    pass


class Generator:
    """
    Main doc generator.

    Arguments:
        input_path -- Path to repo to generate docs.
        logger -- Logger instance.
        docstring_processor -- Docstring converter to Markdown.
        loader -- Loader for python modules.
        output_path -- Path to folder with auto-generated docs to output.
    """

    ignore_paths = ["build/**", "docs/**", "dist/**", "test/**", "tests/**"]

    def __init__(
        self,
        input_path: Path,
        source_paths: Iterable[Path],
        logger: Optional[logging.Logger] = None,
        docstring_processor: Optional[BaseDocstringProcessor] = None,
        loader: Optional[Loader] = None,
        output_path: Optional[Path] = None,
        raise_import_errors: bool = False,
    ) -> None:
        self._logger = logger or logging.Logger("handsdown")
        self._root_path = input_path
        self._output_path = (
            output_path if output_path is not None else (input_path / "docs")
        )

        if not self._output_path.exists():
            self._logger.info(f"Creating folder {self._output_path}")
            self._output_path.mkdir()

        self._raise_import_errors = raise_import_errors
        self._loader = loader or Loader(root_path=self._root_path, logger=self._logger)
        self._docstring_processor = docstring_processor or SmartDocstringProcessor()

        self._source_paths = sorted(source_paths)
        self._module_records = self._build_module_record_list()

        package_names = self._module_records.get_package_names()
        self._docstring_links_re = re.compile(f'`(?:{"|".join(package_names)})\\.\\S+`')
        self._signature_links_re = re.compile(
            f'[ \\[]((?:{"|".join(package_names)})\\.[^() :,]+)'
        )

    def _build_module_record_list(self) -> ModuleRecordList:
        result = ModuleRecordList()
        for source_path in self._source_paths:
            try:
                module_record = self._loader.get_module_record(source_path)
            except LoaderError as e:
                if self._raise_import_errors:
                    raise

                self._logger.warning(
                    f"Skipping {source_path.relative_to(self._root_path)} due to import error: {e}"
                )

            if module_record:
                result.add(module_record)

        return result

    def cleanup_old_docs(self) -> None:
        """
        Remove old docs generated for this module.

        Arguments:
            preserve_paths -- All doc files generated paths that should not be deleted.
        """
        preserve_file_names = self._module_records.get_output_file_names()
        for doc_path in self._output_path.glob("*.md"):
            md_name = doc_path.name
            if md_name in preserve_file_names:
                continue

            file_content = doc_path.read_text()
            is_autogenerated = "Auto-generated documentation" in file_content
            if is_autogenerated:
                self._logger.info(f"Deleting orphaned doc file {md_name}")
                doc_path.unlink()

    def _generate_doc(self, module_record: ModuleRecord) -> None:
        """
        Generate one module doc at once. If `file_path` has nothing to document - return `None`.

        Arguments:
            file_path -- Path to source file.

        Returns:
            A path to generated MD file or None.
        """
        md_name = module_record.output_file_name
        target_file = self._output_path / md_name
        relative_doc_path = target_file.relative_to(self._root_path)
        relative_file_path = module_record.source_path.relative_to(self._root_path)
        self._logger.debug(
            f"Generating doc {relative_doc_path} for {relative_file_path}"
        )

        docstring = self._get_formatted_docstring(module_record)
        content_lines = self._generate_module_doc_lines(module_record)

        md_doc = MDDocument()
        md_doc.append(
            f"> Auto-generated documentation for [{module_record.import_string}](../{relative_file_path}) module."
        )
        if docstring:
            md_doc.append(docstring)
        md_doc.append("\n".join(content_lines))

        if not md_doc.title:
            md_doc.title = ": ".join(module_record.get_title_parts())

        md_doc.ensure_toc_exists()
        md_doc.write(self._output_path / md_name)

    def generate(self) -> None:
        """
        Generate all module docs at once.
        """
        self._logger.debug(
            f"Generating docs for {self._root_path.name} to {self._output_path.relative_to(self._root_path.parent)}"
        )

        for module_record in self._module_records:
            self._generate_doc(module_record)
            output_file_path = self._output_path / module_record.output_file_name
            self._replace_local_links(module_record)
            self.replace_links(output_file_path)

        self._logger.debug(f"Removing orphaned docs")
        self.cleanup_old_docs()

        index_md_path = Path(self._output_path, "index.md")
        self._logger.debug(f"Generating {index_md_path.relative_to(self._root_path)}")
        self._generate_index_md()
        self.replace_links(index_md_path)

    def _replace_local_links(self, module_record: ModuleRecord) -> None:
        output_file_name = self._output_path / module_record.output_file_name
        content = output_file_name.read_text()
        file_changed = False
        for obj in module_record.objects:
            search_str = f"`{obj.title}`"
            if search_str in content:
                title = obj.title
                anchor_link = MDDocument.get_anchor_link(title)
                link = f"[{title}](#{anchor_link})"
                content = content.replace(search_str, link)
                self._logger.debug(f'Adding local link "{title}" to {output_file_name}')
                file_changed = True

        if file_changed:
            output_file_name.write_text(content)

    def replace_links(self, file_path: Path) -> None:
        """
        Replace all import strings with Markdown links. Only import strings that present in this
        package are replaced, so not dead linsk should be generated.

        ```python
        my_md = Path('doc.md')
        my_md.write_text('I love `' + 'handsdown.indent_trimmer.IndentTrimmer.trim_lines` function!')
        handsdown.replace_links(my_md)

        my_md.read_text()
        # 'I love [IndentTrimmer.trim_lines](./handsdown_indent_trimmer.md#indenttrimmertrim_lines) function!'
        ```

        Arguments:
            file_path -- Path to MD document file.
        """
        content = file_path.read_text()
        file_changed = False
        for match in re.findall(self._docstring_links_re, content):
            module_name = match.replace("`", "")
            module_object_record = self._module_records.find_object(module_name)
            if module_object_record is None:
                continue

            md_name = module_object_record.output_file_name
            if md_name == file_path.name:
                continue

            title = module_object_record.title
            anchor_link = MDDocument.get_anchor_link(title)
            link = f"[{title}](./{md_name}#{anchor_link})"
            content = content.replace(match, link)
            self._logger.debug(f'Adding link "{title}" to {file_path.name}')
            file_changed = True

        if file_changed:
            file_path.write_text(content)

    def _generate_module_doc_lines(self, module_record: ModuleRecord) -> List[Text]:
        lines = []
        for module_object_record in module_record.objects:
            lines.append(
                f'{"#" * (module_object_record.level + 2)} {module_object_record.title}\n'
            )

            source_path = module_object_record.source_path
            relative_path = source_path.relative_to(self._root_path)
            lines.append(
                f"[🔍 find in source code](../{relative_path}#L{module_object_record.source_line_number})\n"
            )

            signature = self._loader.get_object_signature(module_object_record.object)

            if signature:
                lines.append(f"```python\n{signature}\n```\n")

            formatted_docstring = self._get_formatted_docstring(
                module_record=module_object_record, signature=signature
            )
            if formatted_docstring:
                lines.extend(formatted_docstring.split("\n"))
                lines.append("")

        return lines

    def _get_formatted_docstring(
        self,
        module_record: Union[ModuleRecord, ModuleObjectRecord],
        signature: Optional[Text] = None,
    ) -> Optional[Text]:
        """
        Get object docstring and convert it to a valid markdown using
        `handsdown.processors.base.BaseDocstringProcessor`.

        Arguments:
            source_path -- Path to object source file.
            module_object -- Object to inspect.
            signature -- Object signature if exists.

        Returns:
            A module docstring with valid markdown.
        """
        output_file_name = module_record.output_file_name
        docstring = module_record.docstring
        if not docstring:
            return None

        sections = self._docstring_processor.build_sections(docstring)
        if signature:
            related_objects = self._get_objects_from_signature(signature)
            for related_object in related_objects:
                if related_object is module_record:
                    continue

                md_link = ""
                if related_object.output_file_name != output_file_name:
                    md_link = f"./{related_object.output_file_name}"

                title = related_object.title
                anchor_link = MDDocument.get_anchor_link(title)
                sections["See also"].append(f"- [{title}]({md_link}#{anchor_link})")
                self._logger.debug(
                    f'Adding link "{title}" to {self._output_path / output_file_name} "See also" section'
                )

        formatted_docstring = self._docstring_processor.render_sections(sections)
        return formatted_docstring.strip("\n")

    def _get_objects_from_signature(self, signature: Text) -> List[ModuleObjectRecord]:
        result: List[ModuleObjectRecord] = []
        for match in re.findall(self._signature_links_re, signature):
            module_object_record = self._module_records.find_object(match)
            if not module_object_record or module_object_record in result:
                continue

            result.append(module_object_record)

        return result

    def _generate_index_md(self) -> None:
        """
        Generate new `index.md`. Copy content from `README.md` and add ToC.
        """
        md_doc = MDDocument()
        readme_path = Path(self._root_path / "README.md")
        if readme_path.exists():
            md_doc.append(readme_path.read_text())

        lines = []
        lines.append("\n## Modules\n")
        last_title_parts: List[Text] = []
        for module_record in self._module_records:
            md_name = module_record.output_file_name
            title_parts = module_record.get_title_parts()
            for index, title_part in enumerate(title_parts[:-1]):
                if (
                    len(last_title_parts) > index
                    and last_title_parts[index] == title_part
                ):
                    continue
                indent = "  " * index
                lines.append(f"{indent}- {title_part}")

            last_title_parts = title_parts
            indent = "  " * (len(title_parts) - 1)
            lines.append(f"{indent}- [{title_parts[-1]}](./{md_name})")

        md_doc.append("\n".join(lines))
        md_doc.ensure_toc_exists()
        md_doc.write(self._output_path / "index.md")

    def _get_md_name(self, path: Path) -> Text:
        relative_path = path.relative_to(self._root_path)
        name_parts = []
        for part in relative_path.parts:
            if part == "__init__.py":
                part = "index"
            stem = part.split(".")[0]
            name_parts.append(stem)

        if not name_parts:
            return "stub.md"

        return f"{'_'.join(name_parts)}.md"

    @staticmethod
    def _get_file_import_string(path: Path) -> Text:
        name_parts = []
        for part in path.parts:
            stem = part.split(".")[0]
            if stem == "__init__":
                continue
            name_parts.append(stem)

        return f"{'.'.join(name_parts)}"

    def _get_title_from_path(self, path: Path) -> Text:
        """
        Converts `pathlib.Path` to a human readable title.

        Arguments:
            path -- Relative path to file or folder

        Returns:
            Human readable title.
        """
        path_parts = path.parts
        name_parts = []
        for path_part in path_parts:
            if path_part == "__init__.py":
                continue
            name = path_part.split(".")[0]
            name = name.replace("__", "").replace("_", " ")
            name = name.capitalize()
            name_parts.append(name)

        if name_parts:
            return ": ".join(name_parts)

        return "Index"

    @staticmethod
    def _get_title_from_md_content(content: Text) -> Optional[Text]:
        lines = content.split("\n")[:10]
        for line in lines:
            if line.startswith("# "):
                return line.split(" ", 1)[-1].strip()

        return None
